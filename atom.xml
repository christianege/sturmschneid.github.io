<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sturmschneid]]></title>
  <link href="http://sturmschneid.github.io/atom.xml" rel="self"/>
  <link href="http://sturmschneid.github.io/"/>
  <updated>2015-04-12T07:44:51+02:00</updated>
  <id>http://sturmschneid.github.io/</id>
  <author>
    <name><![CDATA[Christian Ege]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running BlueZ5 on Yocto/OpenEmbedded]]></title>
    <link href="http://sturmschneid.github.io/blog/2015/04/12/running-bluez5-on-yocto-slash-openembedded/"/>
    <updated>2015-04-12T07:09:49+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2015/04/12/running-bluez5-on-yocto-slash-openembedded</id>
    <content type="html"><![CDATA[<p>At the moment yocto/openembedded ships with <a href="http://www.bluez.org">BlueZ4</a> as the Linux Bluetooth protocol stack. Due to the fact that <a href="http://en.wikipedia.org/wiki/Bluetooth_low_energy">Bluetooth low energy</a> is only supported in BlueZ5 this is a bit of a disappointment. There is a long-standing bug report on this <a href="https://bugzilla.yoctoproject.org/show_bug.cgi?id=5031">#5031 </a>. But since the commit <a href="http://git.yoctoproject.org/cgit/cgit.cgi/poky/commit/?id=1139cc4eef305fc14bc5db19a5f8729e7b3bf27a">1139cc4e&hellip;</a> the used BlueZ version can be selected. According to the reference manual BlueZ5 can be enabled by adding bluez5 to the <a href="http://www.yoctoproject.org/docs/1.8/ref-manual/ref-manual.html#var-DISTRO_FEATURES">DISTRO_FEATURES</a> for me the easiest way to to this was adding the following line to my conf/local.conf in the <a href="http://www.yoctoproject.org/docs/1.8/dev-manual/dev-manual.html#build-directory">Build Directory</a>.</p>

<pre><code>DISTRO_FEATURES = "ext2 alsa wifi usbhost bluetooth bluez5 ${DISTRO_FEATURES_LIBC}"
</code></pre>

<p>This disables x11 for example. But you may also could add something like this:</p>

<pre><code>DISTRO_FEATURES_append = "bluez5"
</code></pre>

<p>After this run an build of your preferred image. In my case this was &ldquo;core-image-base&rdquo;</p>

<pre><code>bitbake core-image-base
</code></pre>

<p>To have full bluetooth support on the target I needed to install some extra packages. To get a list of all bluetooth related packages run the following command. For this you need a <a href="http://www.yoctoproject.org/docs/1.8/ref-manual/ref-manual.html#package-feeds-dev-environment">opkg/ipkg feed</a> server.</p>

<pre><code>root@odroidc1:~# opkg list | grep blue
bluez5 - 5.29-r0 - Linux Bluetooth Stack Userland V5  Linux Bluetooth stack V5 userland
bluez5-dbg - 5.29-r0 - Linux Bluetooth Stack Userland V5 - Debugging files  Linux Bluetooth
bluez5-dev - 5.29-r0 - Linux Bluetooth Stack Userland V5 - Development files  Linux Bluetooth
bluez5-doc - 5.29-r0 - Linux Bluetooth Stack Userland V5 - Documentation files  Linux Bluetooth
bluez5-noinst-tools - 5.29-r0 - Linux Bluetooth Stack Userland V5  Linux Bluetooth stack V5 userland
bluez5-obex - 5.29-r0 - Linux Bluetooth Stack Userland V5  Linux Bluetooth stack V5 userland
bluez5-testtools - 5.29-r0 - Linux Bluetooth Stack Userland V5  Linux Bluetooth stack V5 userland
libasound-module-bluez - 5.29-r0 - Linux Bluetooth Stack Userland V5  Linux Bluetooth stack V5 userland
packagegroup-base-bluetooth - 1.0-r83 - Bluetooth support  Merge machine and distro options to create a basic
</code></pre>

<p>I installed the following packages:</p>

<pre><code>bluez5-testtools, bluez5-noinst-tools
</code></pre>

<p>The later <strong>bluez5-noinst-tools</strong> was required for the gatttool.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Blog Based on Octopress]]></title>
    <link href="http://sturmschneid.github.io/blog/2014/10/25/new-blog-based-on-octopress/"/>
    <updated>2014-10-25T13:40:01+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2014/10/25/new-blog-based-on-octopress</id>
    <content type="html"><![CDATA[<p>This is my new Blog based on <a href="http://octopress.org/">Octopress</a> and <a href="http://kaworu.github.io/octostrap3">Octostrap3</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Yocto Image for the A20 OLinuXino LIME]]></title>
    <link href="http://sturmschneid.github.io/blog/2014/09/26/building-a-yocto-image-for-the-a20-olinuxino-lime/"/>
    <updated>2014-09-26T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2014/09/26/building-a-yocto-image-for-the-a20-olinuxino-lime</id>
    <content type="html"><![CDATA[<p>Some time ago I ordered a <a href="https://www.olimex.com/Products/OLinuXino/A20/A20-OLinuXino-LIME-4GB/open-source-hardware">A20-OLinuXino-LIME-4GB</a> board. This was planed as a replacement for my not so beloved Raspberry PI. I am not that big fan of the PI because of the wacky SD-Card holder and the USB stability. I hope the 4GB NAND of the <a href="https://www.olimex.com/Products/OLinuXino/A20/A20-OLinuXino-LIME-4GB/open-source-hardware">A20-OLinuXino-LIME-4GB</a> Will improve the stability of my target application.</p>

<h3>[Update - 2014-10-01]</h3>

<p>I&rsquo;ve created a successful <a href="https://github.com/linux-sunxi/meta-sunxi/commit/998cbf354423375ceacf735571dab150b9670502">pull-request</a> to merge my changes into the <a href="https://github.com/linux-sunxi/meta-sunxi">meta-sunxi</a> repository and succeeded with the current master branch. Maybe I also start a pull request for the daisy branch. Due  to the fact that the new yocto release is knocking on the door This is may not needed.</p>

<p>As a big fan of the <a href="https://www.yoctoproject.org/">Yocto Project</a> I decided to run poky on my OLinuXino. Due to the fact that the <a href="https://www.olimex.com/Products/OLinuXino/A20/A20-OLinuXino-LIME-4GB/open-source-hardware">A20-OLinuXino-LIME-4GB</a> is not yet officially supported by the <a href="https://github.com/linux-sunxi/meta-sunxi">meta-sunxi layer</a> there are some patches needed. Those patches are located in <a href="https://github.com/cybertux/meta-sunxi/tree/olimex-a20-lime">my fork</a>. The patch set is against the daisy branch</p>

<h1>Preparation</h1>

<p>Clone the git repositories and switch to the daisy branch.</p>

<pre><code>mkdir /data/src/yocto
cd /data/src/yocto
git clone git://git.yoctoproject.org/poky
git clone https://github.com/cybertux/meta-sunxi.git
cd poky
git checkout -b daisy origin/daisy
cd ../meta-sunxi
git checkout -b daisy origin/olimex-a20-lime
</code></pre>

<p>Prepare a warm and cozy environment for the build</p>

<pre><code>cd /data/src/yocto/poky
mkdir -p ../build/a20-lime
source oe-init-build-env ../build/a20-lime
</code></pre>

<p>Add the <a href="https://github.com/linux-sunxi/meta-sunxi">sunxi meta-layer</a> to the build environment</p>

<pre><code>--- a/conf/bblayers.conf
+++ b/conf/bblayers.conf
@@ -9,6 +9,7 @@ BBLAYERS ?= " \
   /data/src/yocto/poky/meta \
   /data/src/yocto/poky/meta-yocto \
   /data/src/yocto/poky/meta-yocto-bsp \
+  /data/src/yocto/meta-sunxi \
   "
 BBLAYERS_NON_REMOVABLE ?= " \
   /data/src/yocto/poky/meta \
</code></pre>

<p>Set the correct target machine and tuning parameters</p>

<pre><code>diff --git a/conf/local.conf b/conf/local.conf
index bcb0864..6a793e6 100644
--- a/conf/local.conf
+++ b/conf/local.conf
@@ -55,7 +55,7 @@ PARALLEL_MAKE ?= "-j ${@oe.utils.cpu_count()}"
 #MACHINE ?= "edgerouter"
 #
 # This sets the default machine to be qemux86 if no other machine is selected:
-MACHINE ??= "qemux86"
+MACHINE ??= "olinuxino-a20-lime"

 #
 # Where to place downloads
@@ -125,7 +125,7 @@ DISTRO ?= "poky"
 #  - 'package_rpm' for rpm style packages
 # E.g.: PACKAGE_CLASSES ?= "package_rpm package_deb package_ipk"
 # We default to rpm:
-PACKAGE_CLASSES ?= "package_rpm"
+PACKAGE_CLASSES ?= "package_ipk"

 #
 # SDK/ADT target architecture
@@ -134,7 +134,19 @@ PACKAGE_CLASSES ?= "package_rpm"
 # you can build the SDK packages for architectures other than the machine you are
 # running the build on (i.e. building i686 packages on an x86_64 host).
 # Supported values are i686 and x86_64
-#SDKMACHINE ?= "i686"
+SDKMACHINE ?= "i686"
+
+#
+# The default machine settings are meant to be the lowest common denominator,
+# maximizing generality. Significantly better performance (2x-3x) can be achieved
+# with the following settings:
+#
+# Allwinner A20
+#
+# For Allwinner A20 (Cubieboard2/CubieTruck), the following tuning options are recommended:
+#
+# Enable hardfloat, thumb2 and neon capabilities
+DEFAULTTUNE = "cortexa7hf-neon-vfpv4"

 #
 # Extra image configuration defaults
</code></pre>

<h1>Building the image</h1>

<p>Now the image can be build, lean back and grap some coffee, beer, &hellip;</p>

<pre><code>bitbake core-image-base

[...]
Build Configuration:
BB_VERSION        = "1.22.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "Ubuntu-12.04"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "olinuxino-a20-lime"
DISTRO            = "poky"
DISTRO_VERSION    = "1.6.1"
TUNE_FEATURES     = "armv7a vfp neon callconvention-hard vfpv4 cortexa7"
TARGET_FPU        = "vfp-vfpv4-neon"
meta
meta-yocto
meta-yocto-bsp    = "daisy:a4d8015687cf9ddd6ef563e29cf840698f81c099"
meta-sunxi        = "olimex-a20-lime:5bb9da72c24a442eecd827a9b85f903281357815"
[...]
</code></pre>

<p>After a successful build all images are located in the folder</p>

<pre><code>/data/src/yocto/build/a20-lime/tmp/deploy/images/olinuxino-a20-lime/
</code></pre>

<h1>Building the SDK</h1>

<p>Sometimes it is handy to have a toolchain apart from the whole yocto/poky environment. So lets build some</p>

<pre><code>bitbake -cpopulate_sdk core-image-base
</code></pre>

<p>This will take mostly as long as the image build so again grab some coffee, beer or &hellip;..
The result is located here:</p>

<pre><code>/data/src/yocto/build/a20-lime/tmp/deploy/sdk/olinuxino-a20-lime/poky-eglibc-i686-core-image-base-cortexa7hf-vfp-vfpv4-neon-toolchain-1.6.1.sh
</code></pre>

<h1>Installation of the Toolchain</h1>

<p>You may need root access to install in /opt</p>

<pre><code>sudo  tmp/deploy/sdk/poky-eglibc-i686-core-image-base-cortexa7hf-vfp-vfpv4-neon-toolchain-1.6.1.sh
Enter target directory for SDK (default: /opt/poky/1.6.1):
You are about to install the SDK to "/opt/poky/1.6.1". Proceed[Y/n]?y
Extracting SDK...
Setting it up...done
SDK has been successfully set up and is ready to be used.
</code></pre>

<h1>Using the SDK</h1>

<p>To use the SDK we have to source the set-up script</p>

<pre><code>source  /opt/poky/1.6.1/environment-setup-cortexa7hf-vfp-vfpv4-neon-poky-linux-gnueabi
</code></pre>

<p>After this some variables should be set like this</p>

<pre><code>echo $CC
arm-poky-linux-gnueabi-gcc -march=armv7-a -mthumb-interwork -mfloat-abi=hard -mfpu=neon-vfpv4 -mtune=cortex-a7 --sysroot=/opt/poky/1.6.1/sysroots/cortexa7hf-vfp-vfpv4-neon-poky-linux-gnueabi
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sti7111 (ST40) JTAG Preparations]]></title>
    <link href="http://sturmschneid.github.io/blog/2014/06/15/sti7111-st40-jtag-preparations/"/>
    <updated>2014-06-15T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2014/06/15/sti7111-st40-jtag-preparations</id>
    <content type="html"><![CDATA[<p>While I almost smashed my Spark 7111 Box during <a href="http://project-magpie.github.io/2013/10/02/that-was-a-close-shave/">UBI experiments</a> I decided to build a JTAG adapter for the ST40 CPU. After getting a little more familiar with eagle my second design ended in the <a href="https://github.com/project-magpie/jtag-adapter">ST40 JTAG adapter</a>.</p>

<p>I ordered the PCB at <a href="http://www.seeedstudio.com/service/">Seeedstudio Fusion PCB</a> and was impressed how cheap and fast they are.</p>

<p><img src="http://sturmschneid.github.io/images/jtag/jtag_pcb.png"></p>

<p>After assembly of the PCB the JTAG adapter have to be connected to the STB. If you are unsure about the pinning you can easily check if Pin-2 is connected to GND with a multimeter.</p>

<p><img src="http://sturmschneid.github.io/images/jtag/spark_jtag_pinout.png"></p>

<p>A more detailed version reconstructed in eagle.</p>

<p><img src="http://sturmschneid.github.io/images/jtag/spark_jtag_pinout_eagle.png"></p>

<p>Anyway, most hardware is useless without software. To use the JTAG Adapter the <a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/CD17379953.pdf">ST40 Micro Toolset</a> is needed. You can grab your version of the ST40 Micro Toolset at the <a href="ftp://ftp.stlinux.com/pub/tools/products/st40tools/ST40_GNU_R5.1.0/">STM ftp server</a>. As usual I decided to take the linux version (R5.1.0). I have tested with Ubuntu 12.04. Maybe the 32bit compatibility libs have to be installed if you are running a 64bit distro. You also need the <a href="ftp://ftp.stlinux.com/pub/tools/products/stmc2/R1.6.0/doc/release_notes.htm">ST Micro Connection Package R1.6.0.</a>. After Installation the folder structure should look like this:</p>

<pre><code>$ tree -L 1 /opt/STM/
/opt/STM/
├── ST40R5.1.0
└── STMCR1.6.0
</code></pre>

<p>To be able to execute the binaries some modifications to the PATH and LD_LIBRARY_PATH variable have to be made.</p>

<pre><code>export LD_LIBRARY_PATH=/opt/STM/STMCR1.6.0/lib:/opt/STM/ST40R5.1.0/lib
export PATH=/opt/STM/ST40R5.1.0/bin:/opt/STM/STMCR1.6.0/bin:$PATH
</code></pre>

<p>Now you sould be able to execute the following command</p>

<pre><code>$ sh4xrun
usage: /opt/STM/ST40R5.1.0/bin/sh4xrun [-c command] [-d directory] [-e filename] [-f] [-g gdbpath] [-h] [-i filename] [-t     target] [-u gdbname] [-v] [-x filename] [-A command] [-B command] [-C option] [-D] [-T timeout] [-V] [-a|--] [arguments]
  -a arguments  target program arguments
  -c command    connection command (default is sh4tp)
  -d directory  directory in which to search for command files
  -e filename   executable file to load
  -f            (ignored)
  -g gdbpath    specify path to GDB
  -h            display help
  -i filename   command script file to source
  -t target     target specification
  -u gdbname    specify name of GDB
  -v            verbose
  -x filename   use filename instead of .shgdbinit
  -A command    execute command after running program
  -B command    execute command before running program
  -C option     connection command option
  -D            debug (very verbose)
  -T timeout    maximum time for executing on target
  -V            version string
</code></pre>

<p>With this command a executable can be uploaded and executed right on the box. But what kind of executable is worthwhile to be uploaded? On Avi+ Forum they use a tool called flasher which is upload to the box. I prefer to use a self compiled version of u-boot. And honestly I did not managed to compile a flasher for the sti7111.</p>

<h2>Compilation of U-Boot</h2>

<p>Before we can compile the u-boot boot loader we have to get the source</p>

<pre><code>$ git clone git://git.stlinux.com/stm/u-boot.git
$ cd u-boot/
$ git checkout -b stmicro-1.3.1 origin/stmicro-1.3.1
</code></pre>

<p>I decided to use stmicro-1.3.1 branch It sounds familiar and I was unable to build the stmicro branch. To compile the source I used a toolchain I&rsquo;ve created with to meta-stlinux layer and yocto.</p>

<pre><code>$ source /opt/poky/1.5.1/environment-setup-sh4-poky-linux
$ export CROSS_COMPILE=sh4-poky-linux-
$ unset LDFLAGS
$ make hdk7111_config
$ vim ./cpu/sh/config.mk
# remove option  -m4-nofpu
</code></pre>

<p>After a successful compilation you have a file called u-boot. This can be uploaded by executing:</p>

<pre><code>sh4xrun -c sh4tp -t STMCLT1000_A:sat7111:st40,debug=2 -e /data/src/u-boot/u-boot
</code></pre>

<p>On a working serial console connected to the STB you should see something like this:</p>

<pre><code>Board: STx7111-HDK  [29-bit mode]


U-Boot 1.3.1-dirty (Jun 15 2014 - 18:23:57) - stm23-2011-12-08

DRAM:  256 MiB
NOR:     8 MiB
NAND:  Bad block table found at page 262080, version 0x01
Bad block table found at page 262016, version 0x01
nand_read_bbt: Bad block at 0x04400000
nand_read_bbt: Bad block at 0x06580000
nand_read_bbt: Bad block at 0x065a0000
nand_read_bbt: Bad block at 0x0e580000
nand_read_bbt: Bad block at 0x0e5a0000
nand_read_bbt: Bad block at 0x10c00000
nand_read_bbt: Bad block at 0x10c20000
nand_read_bbt: Bad block at 0x16580000
nand_read_bbt: Bad block at 0x165a0000
nand_read_bbt: Bad block at 0x18c00000
nand_read_bbt: Bad block at 0x18c20000
nand_read_bbt: Bad block at 0x1dc40000
nand_read_bbt: Bad block at 0x1dc60000
nand_read_bbt: Bad block at 0x1e580000
nand_read_bbt: Bad block at 0x1e5a0000
512 MiB
SPI:  ERROR: Unknown SPI Device detected, status = 0xff
*** Warning - bad CRC, using default environment

In:    serial
Out:   serial
Err:   serial
</code></pre>

<p>It looks like the SPI NOR Flash is not supported by this version of u-boot. So work is to do&hellip;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EDID Mission Accomplished]]></title>
    <link href="http://sturmschneid.github.io/blog/2014/04/29/edid-mission-accomplished/"/>
    <updated>2014-04-29T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2014/04/29/edid-mission-accomplished</id>
    <content type="html"><![CDATA[<p>After my <a href="http://project-magpie.github.io/2014/04/26/pursue-hdmi-edid-bugs/">HDMI EDID analisys</a> I decided getting more in touch with the hardware. I tried to trace the loose ends and checked where the onboard EEPROM is located. The next step was disabling the EEPROM and connecting the STB I2C Bus to the HDMI side.As in my previous <a href="2014/04/26/pursue-hdmi-edid-bugs">post</a> expected the missing SOT-23 parts near the HDMI output form a level shifter which convert the 3.3V I2C STB level to the 5V level of the HDMI side an vice versa.</p>

<p>A detailed description of such an level shifter is described in an application note from <a href="http://www.adafruit.com/datasheets/an97055.pdf">Phillips</a>/<a href="http://www.nxp.com/documents/application_note/AN10441.pdf">NXP</a>.</p>

<p>I started with the trace of the EEPROM. I finally found the EEPROM.</p>

<p><img src="http://sturmschneid.github.io/assets/edid/edid_eeprom.jpg" alt="EDID EEPROM" /></p>

<p>There are two serial resistors between I2C SCL and I2C SDA. Which can be more or less easily removed.</p>

<p><img src="http://sturmschneid.github.io/assets/edid/edid_eeprom_disabled.jpg" alt="EDID EEPROM disabled" /></p>

<p>After soldering my very first sot-23 transistor which made me feeling like my soldering iron is too huge for decent jobs. I cursed myself for not taking the box to work where we do have a more professional equipement at least when it comes to soldering irons.</p>

<p>The result looks ugly but seems to work.</p>

<p><img src="http://sturmschneid.github.io/assets/edid/edid_transistor.jpg" alt="EDID Transistor" /></p>

<p>As Transistor I&rsquo;ve chosen some  N-Channel Field Effect Transistor. Anything like a <a href="http://www.fairchildsemi.com/ds/2N/2N7000.pdf">2N7002</a> or a <a href="http://www.fairchildsemi.com/ds/BS/BSS138.pdf">BSS138</a> should do the job.</p>

<p>For me the final result was a working EDID readout of the HDMI monitor&rsquo;s EDID EEPROM. And the first time the STB took the correct HDMI-CEC address. I had not been able to check levels and edges of the 5V signal and the ultimate HDMI-CEC test also have to wait some time. Because my test lab HDMI monitor have no HDMI-CEC support.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pursue HDMI EDID Bugs]]></title>
    <link href="http://sturmschneid.github.io/blog/2014/04/26/pursue-hdmi-edid-bugs/"/>
    <updated>2014-04-26T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2014/04/26/pursue-hdmi-edid-bugs</id>
    <content type="html"><![CDATA[<p>Today I tried to track down the <a href="http://en.wikipedia.org/wiki/Extended_display_identification_data">EDID (&ldquo;Extended display identification data&rdquo;)</a> bug on my STi7111 (Golden Media 990CR ) spark box. <a href="http://en.wikipedia.org/wiki/Extended_display_identification_data">EDID</a> is needed to detect the display attached to the set-top box. On the newer STi7105 based boxes this works quite good. But on the STi7111 based spark boxes there is a hardware issue.</p>

<p>During EDID query the frame-buffer driver prints out the following warning message:</p>

<pre><code>stmfb: first EDID byte (255) is corrupt, attempting to fix..
stmfb: Invalid extension header checksum block0
stmfb: first EDID byte (255) is corrupt, attempting to fix..
stmfb: Invalid extension header checksum block0
stmfb: first EDID byte (255) is corrupt, attempting to fix..
stmfb: Invalid extension header checksum block0
stmfb: first EDID byte (255) is corrupt, attempting to fix..
stmfb: Invalid extension header checksum block0
stmfb: EDID Read Error, setup safe EDID
stmfb: Setting Safe EDID
</code></pre>

<p>So I decided to take a look at the hardware and do some test. Because EDID is needed for a working <a href="http://en.wikipedia.org/wiki/HDMI#CEC">HDMI-CEC</a> set-up. The EDID information is stored inside an <a href="http://en.wikipedia.org/wiki/EEPROM">EEPROM</a> on the Television/Montor. The EEPROM is accessed by the STB via an I2C bus.</p>

<p>The result looks a little bit chaotic isn&rsquo;t it?</p>

<p><img src="http://sturmschneid.github.io/assets/edid/overview.jpg" alt="This is what it all ended." /></p>

<p>The image shows the set-top box, a <a href="https://www.saleae.com/logic16">salea logic16</a> logic analyser and a <a href="http://dangerousprototypes.com/docs/Bus_Pirate">DP Bus Pirate</a>. The salea logic analyser is to listen to I2C communication between the various loose ends. Before we can access the HDMI connector and the I2C EDID data lines we have to remove the Ethernet board. This is achieved by removing just one screw and lifting the complete Ethernet board.</p>

<p><img src="http://sturmschneid.github.io/assets/edid/ethernet_board.jpg" alt="Remove the Ethernet board" /></p>

<p>After removing the Ethernet board it looks like this:</p>

<p><img src="http://sturmschneid.github.io/assets/edid/edid_stuff.jpg" alt="EDID stuff" /></p>

<p>For debugging purposes I soldered some wires to the related components. There are two types of I2C bus involved. The one from HDMI which is a 5V type and the one from the STB which is at a 3.3V level. So the not applied components seems to form a level shifter. If I attach an HDMI monitor to the STB I can see transfers from STB to an EEPROM on the board which response with 0xFF in all bytes. But no communication over HDMI. Because the loose ends are not connected.</p>

<p><img src="http://sturmschneid.github.io/assets/edid/cable_zoom.jpg" alt="EDID details" /></p>

<p>With an attached <a href="http://dangerousprototypes.com/docs/Bus_Pirate">bus pirate</a> to the HDMI I2C bus I can readout the EDID information from the attached monitor.</p>

<pre><code>HiZ&gt;m
1. HiZ
2. 1-WIRE
3. UART
4. I2C
5. SPI
6. 2WIRE
7. 3WIRE
8. KEYB
9. LCD
10. PIC
11. DIO
x. exit(without change)

(1)&gt;4
I2C mode:
 1. Software
 2. Hardware

(1)&gt;1
Set speed:
 1. ~5KHz
 2. ~50KHz
 3. ~100KHz
 4. ~400KHz
</code></pre>

<p>The i2c sequence to read data from the EEPROM have to define a start address where we want to read from:</p>

<pre><code>I2C&gt;[0xa0 0]
I2C START BIT
WRITE: 0xA0 ACK
WRITE: 0x00 ACK
I2C STOP BIT
</code></pre>

<p>With this we start from address 0.</p>

<p>So now lets read 128 byte of EDID data:</p>

<pre><code>I2C&gt;[0xa1 r:128]
I2C START BIT
WRITE: 0xA1 ACK
READ: 0x00  ACK 0xFF  ACK 0xFF  ACK 0xFF  ACK 0xFF  ACK 0xFF  ACK 0xFF  ACK 0x00  ACK 0x04  ACK 0x72  ACK 0x30  ACK 0x02  ACK 0x01  ACK 0x00  ACK 0x00  ACK 0x00  ACK 0x08  ACK 0x15  ACK 0x01  ACK 0x03      ACK
 0x80  ACK 0x33  ACK 0x1D  ACK 0x78  ACK 0x0A  ACK 0x90  ACK 0x85  ACK 0xA3  ACK 0x58  ACK 0x53  ACK 0x9F  ACK 0x26  ACK 0x0F  ACK 0x50  ACK 0x54  ACK 0xBF  ACK 0x6F  ACK 0x00  ACK 0x71  ACK 0x4F  ACK     0x81
  ACK 0xC0  ACK 0xD1  ACK 0xC0  ACK 0xB3  ACK 0x00  ACK 0x81  ACK 0x80  ACK 0x01  ACK 0x01  ACK 0x01  ACK 0x01  ACK 0x01  ACK 0x01  ACK 0x02  ACK 0x3A  ACK 0x80  ACK 0x18  ACK 0x71  ACK 0x38  ACK 0x2D      ACK
 0x40  ACK 0x58  ACK 0x2C  ACK 0x45  ACK 0x00  ACK 0xFD  ACK 0x1E  ACK 0x11  ACK 0x00  ACK 0x00  ACK 0x18  ACK 0x01  ACK 0x1D  ACK 0x00  ACK 0x72  ACK 0x51  ACK 0xD0  ACK 0x1E  ACK 0x20  ACK 0x6E  ACK     0x28
  ACK 0x55  ACK 0x00  ACK 0xFD  ACK 0x1E  ACK 0x11  ACK 0x00  ACK 0x00  ACK 0x1E  ACK 0x00  ACK 0x00  ACK 0x00  ACK 0xFD  ACK 0x00  ACK 0x38  ACK 0x4C  ACK 0x1E  ACK 0x4B  ACK 0x0F  ACK 0x00  ACK 0x0A      ACK
 0x20  ACK 0x20  ACK 0x20  ACK 0x20  ACK 0x20  ACK 0x20  ACK 0x00  ACK 0x00  ACK 0x00  ACK 0xFC  ACK 0x00  ACK 0x4D  ACK 0x32  ACK 0x33  ACK 0x30  ACK 0x48  ACK 0x44  ACK 0x4C  ACK 0x0A  ACK 0x20  ACK     0x20
  ACK 0x20  ACK 0x20  ACK 0x20  ACK 0x01  ACK 0x56
NACK
I2C STOP BIT
</code></pre>

<p>We do not need any pull-ups power set-up for the Bus Pirate because the bus is already pulled high by the STB. And due to the fact that I2C only pulls level to low we need no adjustment for 3.3V and 5V.</p>

<p>With some editor regular-expression magic we can form a python snippet to create a binary EDID file we can analyse later.</p>

<pre><code>import struct
edid_txt = [ '0x00', '0xFF', '0xFF', '0xFF', '0xFF', '0xFF', '0xFF', '0x00',
             '0x04', '0x72', '0x30', '0x02', '0x01', '0x00', '0x00', '0x00',
             '0x08', '0x15', '0x01', '0x03', '0x80', '0x33', '0x1D', '0x78',
             '0x0A', '0x90', '0x85', '0xA3', '0x58', '0x53', '0x9F', '0x26',
             '0x0F', '0x50', '0x54', '0xBF', '0x6F', '0x00', '0x71', '0x4F',
             '0x81', '0xC0', '0xD1', '0xC0', '0xB3', '0x00', '0x81', '0x80',
             '0x01', '0x01', '0x01', '0x01', '0x01', '0x01', '0x02', '0x3A',
             '0x80', '0x18', '0x71', '0x38', '0x2D', '0x40', '0x58', '0x2C',
             '0x45', '0x00', '0xFD', '0x1E', '0x11', '0x00', '0x00', '0x18',
             '0x01', '0x1D', '0x00', '0x72', '0x51', '0xD0', '0x1E', '0x20',
             '0x6E', '0x28', '0x55', '0x00', '0xFD', '0x1E', '0x11', '0x00',
             '0x00', '0x1E', '0x00', '0x00', '0x00', '0xFD', '0x00', '0x38',
             '0x4C', '0x1E', '0x4B', '0x0F', '0x00', '0x0A', '0x20', '0x20',
             '0x20', '0x20', '0x20', '0x20', '0x00', '0x00', '0x00', '0xFC',
             '0x00', '0x4D', '0x32', '0x33', '0x30', '0x48', '0x44', '0x4C',
             '0x0A', '0x20', '0x20', '0x20', '0x20', '0x20', '0x01', '0x56' ]

f = open('edid.bin', 'w')

for i in edid_txt:
    bin = int(i,16)
    f.write(struct.pack('B',bin))

f.close()
</code></pre>

<p>For EDID analysis I&rsquo;ve used to tool &ldquo;read-edid&rdquo; which contains a tool called &ldquo;edid-decode&rdquo;.</p>

<pre><code>$ edid-decode edid.bin
Extracted contents:
header:          00 ff ff ff ff ff ff 00
serial number:   04 72 30 02 01 00 00 00 08 15
version:         01 03
basic params:    80 33 1d 78 0a
chroma info:     90 85 a3 58 53 9f 26 0f 50 54
established:     bf 6f 00
standard:        71 4f 81 c0 d1 c0 b3 00 81 80 01 01 01 01 01 01
descriptor 1:    02 3a 80 18 71 38 2d 40 58 2c 45 00 fd 1e 11 00 00 18
descriptor 2:    01 1d 00 72 51 d0 1e 20 6e 28 55 00 fd 1e 11 00 00 1e
descriptor 3:    00 00 00 fd 00 38 4c 1e 4b 0f 00 0a 20 20 20 20 20 20
descriptor 4:    00 00 00 fc 00 4d 32 33 30 48 44 4c 0a 20 20 20 20 20
extensions:      01
checksum:        56

Manufacturer: ACR Model 230 Serial Number 1
Made week 8 of 2011
EDID version: 1.3
Digital display
Maximum image size: 51 cm x 29 cm
Gamma: 2.20
Supported color formats: RGB 4:4:4, YCrCb 4:2:2
First detailed timing is preferred timing
Established timings supported:
  720x400@70Hz
  640x480@60Hz
  640x480@67Hz
  640x480@72Hz
  640x480@75Hz
  800x600@56Hz
  800x600@60Hz
  800x600@75Hz
  832x624@75Hz
  1024x768@60Hz
  1024x768@70Hz
  1024x768@75Hz
  1280x1024@75Hz
Standard timings supported:
  1152x864@75Hz
  1280x768@60Hz
  1920x1152@60Hz
  1680x1050@60Hz
  1280x1024@60Hz
Detailed mode: Clock 148.500 MHz, 509 mm x 286 mm
               1920 2008 2052 2200 hborder 0
               1080 1084 1089 1125 vborder 0
               -hsync -vsync
Detailed mode: Clock 74.250 MHz, 509 mm x 286 mm
               1280 1390 1430 1650 hborder 0
                720  725  730  750 vborder 0
               +hsync +vsync
Monitor ranges: 56-76HZ vertical, 30-75kHz horizontal, max dotclock 150MHz
Monitor name: M230HDL
     Has 1 extension blocks
Checksum: 0x56
</code></pre>

<p>The result looks quite good isn&rsquo;t it? One of the next step would be to connect the loose ends. Or trying to write useful information to the on board eeprom.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Assign Static Device Name for USB Infrared Toy]]></title>
    <link href="http://sturmschneid.github.io/blog/2014/04/21/assign-static-device-name-for-usb-infrared-toy/"/>
    <updated>2014-04-21T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2014/04/21/assign-static-device-name-for-usb-infrared-toy</id>
    <content type="html"><![CDATA[<p>The last few days I was playing arround with my <a href="http://dangerousprototypes.com/docs/USB_Infrared_Toy">USB Infrared Toy v2</a> from Dangerous Prototypes. Due to the fact that I have attached some more devices which are detected as <strong>/dev/ACM[0-9]</strong> I decided to write an udev rule to assign a static device name.</p>

<p>I stored the rule in the following file: <strong>/etc/udev/rules.d/98-ir-toy-v2.rules</strong></p>

<pre><code>SUBSYSTEM=="tty", ATTRS{manufacturer}=="Dangerous Prototypes", ATTRS{idProduct}=="fd08", SYMLINK+="ir_toy" MODE="0666"
</code></pre>

<p>Maybe the field <strong>&ldquo;ATTRS{idProduct}==&#8221;fd08&rdquo;&ldquo;</strong> have to be tweaked for versions differnet of v2. With this rule the IR Toy is accessible via <strong>/dev/ir_toy</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rewriting History]]></title>
    <link href="http://sturmschneid.github.io/blog/2013/11/04/rewriting-history/"/>
    <updated>2013-11-04T00:00:00+01:00</updated>
    <id>http://sturmschneid.github.io/blog/2013/11/04/rewriting-history</id>
    <content type="html"><![CDATA[<p>Sometimes history has to be rewritten. In real life this is hopefully not possible yet. But in case of git this is possible. Some projecs start with a small repository which evolves over the time to a big bloated repository. Other ones start already bloated. In some cases the wish to split-up the repository in smaller chunks emerges. With some advice from <a href="http://seife.kernalert.de/blog/">Stefan Seyfried</a> I learned how to rewrite history</p>

<p>The goal was to extract the driver directory from the <a href="https://gitorious.org/open-duckbox-project-sh4/tdt">tdt</a> repository like <a href="https://gitorious.org/neutrino-mp/tdt-driver">Stefan</a> already did.</p>

<p>These are the steps to follow:</p>

<pre><code>$ cd /dev/shm/
$ git clone --reference /net/transfer/spark71xx/tdt https://git.gitorious.org/open-duckbox-project-sh4/tdt.git tdt-driver
$ cd tdt-driver/
$ git filter-branch --subdirectory-filter tdt/cvs/driver
</code></pre>

<p>The first step speeds up the process of rewriting by doing it all in memory instead of writing everything onto a slow disk device. But please remember to push your work onto a less volatile memory.</p>

<pre><code>$ cd /dev/shm/
</code></pre>

<p>In the second step the original repository is cloned. To again speedup things I used a local copy as reference. After cloning the directory structure looked like this</p>

<pre><code>$ tree -d -L 3 tdt/
tdt/
├── custom
├── cvs
│   ├── apps
│   │   ├── dvb
│   │   ├── enigma1-hd
│   │   ├── enigma2
│   │   ├── misc
│   │   ├── neutrino
│   │   ├── tuxbox
│   │   └── vdr
│   ├── boot
│   │   └── u-boot-tufsbox
│   ├── cdk
│   │   ├── integrated_firmware
│   │   ├── make
│   │   ├── own_build
│   │   ├── Patches
│   │   ├── root
│   │   ├── static
│   │   └── tfinstaller
│   ├── driver
│   │   ├── adb_box_fan
│   │   ├── avs
│   │   ├── boxtype
│   │   ├── bpamem
│   │   ├── button
│   │   ├── button_hs5101
│   │   ├── cec
│   │   ├── cec_adb_box
│   │   ├── cic
│   │   ├── compcache
│   │   ├── cpu_frequ
│   │   ├── dvbt
│   │   ├── e2_proc
│   │   ├── frontcontroller
│   │   ├── frontends
│   │   ├── i2c_spi
│   │   ├── include
│   │   ├── ipbox99xx_fan
│   │   ├── led
│   │   ├── logfs
│   │   ├── multicom-3.2.2
│   │   ├── multicom-3.2.4
│   │   ├── multicom-3.2.4_rc3
│   │   ├── multicom-4.0.6
│   │   ├── old
│   │   ├── player2_131
│   │   ├── player2_179
│   │   ├── player2_191
│   │   ├── pti
│   │   ├── rmu
│   │   ├── sata_switch
│   │   ├── siinfo
│   │   ├── simu_button
│   │   ├── smartcard
│   │   ├── stgfb
│   │   ├── tfswitch
│   │   ├── ufs922_fan
│   │   └── wireless
│   └── hostapps
│       ├── flash
│       ├── mkfs.jffs2
│       └── mklibs
└── flash
    ├── at7500
    │   ├── extras
    │   ├── scripts
    │   ├── scripts_209
    │   └── scripts_extended
    ├── common
    │   ├── fup.src
    │   ├── mup.src
    │   └── pad.src
    ├── hs7810a
    │   ├── extras
    │   └── scripts
    ├── spark
    │   ├── extras
    │   └── scripts
    ├── tf7700hdpvr
    ├── ufc960
    │   ├── extra
    │   └── scripts
    ├── ufs910
    │   └── scripts
    ├── ufs912
    │   ├── extras
    │   └── scripts
    └── ufs913
        ├── extra
        ├── scripts
        └── test
</code></pre>

<p>The last step extracts just the directory  &lsquo;&#8217;tdt/cvs/driver&rsquo;&#8217;</p>

<pre><code>$ git filter-branch --subdirectory-filter tdt/cvs/driver
</code></pre>

<p>After this step the filesystem looks like this:</p>

<pre><code>$ tree -d -L 1 tdt-driver/
tdt-driver/
├── adb_box_fan
├── avs
├── boxtype
├── bpamem
├── button
├── button_hs5101
├── cec
├── cec_adb_box
├── cic
├── compcache
├── cpu_frequ
├── dvbt
├── e2_proc
├── frontcontroller
├── frontends
├── i2c_spi
├── include
├── ipbox99xx_fan
├── led
├── logfs
├── multicom-3.2.2
├── multicom-3.2.4
├── multicom-3.2.4_rc3
├── multicom-4.0.6
├── old
├── player2_131
├── player2_179
├── player2_191
├── pti
├── rmu
├── sata_switch
├── siinfo
├── simu_button
├── smartcard
├── stgfb
├── tfswitch
├── ufs922_fan
└── wireless
</code></pre>

<p>There are more steps recommended in a <a href="http://stackoverflow.com/questions/359424/detach-subdirectory-into-separate-git-repository/1591174#1591174">stackoverflow</a> article. These steps had not been necessary for my example.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UBIFS as Rootfs]]></title>
    <link href="http://sturmschneid.github.io/blog/2013/10/22/ubifs-as-rootfs/"/>
    <updated>2013-10-22T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2013/10/22/ubifs-as-rootfs</id>
    <content type="html"><![CDATA[<p>This Post describes how to get startet with an UBIFS root filesystem. I suppose you are using a image generated for the &ldquo;spark&rdquo; device. I have not done any tests with &ldquo;spark7162&rdquo;. For the spark boxes there is automatically a ubifs image generated.</p>

<p>Generate a core-image-minimal for example. This assumes You already have set-up the yocto build environment.</p>

<pre><code>MACHINE=spark bitbake core-image-minimal
</code></pre>

<p>The resulting image can be found here</p>

<pre><code>tmp/deploy/images/core-image-minimal-spark.ubi
</code></pre>

<p>This is a ubivolume which can be burned to flash &hellip;</p>

<h1>The Linux Way</h1>

<p>For flashing from Linux <a href="https://github.com/project-magpie/meta-stlinux/wiki/Boot-from-USB-Stick">booting over USB</a> is recommended. Be cause we do not want to bite the hand that feeds us. For debugging and configuration purposes a Nullmodem Cable and a Terminal Emulator is recommended.</p>

<h2>Flashing the image</h2>

<p>To get a list with the mtd devices just dump the content of &ldquo;/proc/mtd&rdquo;</p>

<pre><code>root@spark:~# cat /proc/mtd
dev:    size   erasesize  name
mtd0: 00080000 00010000 "Boot firmware"
mtd1: 00700000 00010000 "Kernel"
mtd2: 00080000 00010000 "Reserve"
mtd3: 00800000 00020000 "Spark Kernel"
mtd4: 17800000 00020000 "Spark Rootfs"
mtd5: 00800000 00020000 "E2 Kernel"
mtd6: 05000000 00020000 "E2 RootFs"
</code></pre>

<p>We want to modify the Partion number &ldquo;6&rdquo; also known as &ldquo;E2 RootFs&rdquo;. Be carefull to not erase Number &ldquo;0&rdquo; otherwise your bootloader is blown.
At first you have to transfer the image. In absence of any other tools I do use netcat again.</p>

<p>On the host (quadros) run this</p>

<pre><code>$ cat tmp/deploy/images/core-image-minimal-spark.ubi | nc -l -v 3333
</code></pre>

<p>On the target run this</p>

<pre><code>root@spark:~# nc  quadros 3333 &gt; /tmp/image.ubi
</code></pre>

<p>Now we can burn the image onto the flash</p>

<pre><code>root@spark:~# flash_eraseall /dev/mtd6
root@spark:~# ubiformat /dev/mtd6 -q -y -f /tmp/image.ubi
</code></pre>

<h2>Choosing the right commandline</h2>

<p>I had a some difficulties with the console. The default bootagrs point to &ldquo;ttyAS1&rdquo; but I have to use ttyAS0. So I have to check this. This is the command line which works for me.</p>

<pre><code>setenv bootargs 'console=ttyAS0,115200 rw init=/bin/devinit coprocessor_mem=4m@0x40000000,4m@0x40400000 printk=1 nwhwconf=device:eth0,hwaddr:00:80:E1:12:40:61 rw ip=172.100.100.249:172.100.100.174:172.100.100.174:255.255.0.0:LINUX7109:eth0:off bigphysarea=6000 stmmaceth=msglvl:0,phyaddr:2,watchdog:5000 ubi.mtd=6 rootfstype=ubifs root=ubi0:rootfs'
</code></pre>

<h1>The spark u-boot</h1>

<p>The spark bootloader has a nice menu integrated. With this you can also write images from a USB stick to the flash. Notice this is not the recommended way. Using ubiformat keeps all required information about the underlying flash device. To get started you need a USB-Stick which is supported by the spark u-noot. To boot the UBI image the commandline also have be tweaked to use ubi instead jffs2. Please have a look at the The Linux Way section for advise.</p>

<ul>
<li>Format USB-thumb drive with a single FAT32 partition</li>
<li>Create an enigma2 folder on the USB-thumb drive</li>
<li>Copy the file core-image-minimal-spark.ubi to the enigma2 folder and rename it to e2jffs2.img</li>
<li>Copy the file uImage-spark.bin to the enigma2 folder as-well and rename it to uImage</li>
<li>Turn the Set-Top-Box off by the power switch</li>
<li>Put the USB-Stick into the USB-Slot at the back of the STB. Not the front one!</li>
<li>Press the OK at the Front-Panel and keep it pressed.</li>
<li>Turn on the box by the power switch.</li>
<li>Wait until you read &ldquo;Forc&rdquo; on the display</li>
<li>Release the OK Button. Now you can press the Button V+ -> (right).</li>
<li>After this you can read &ldquo;U LD&rdquo; on the display.</li>
<li>The flashing of the image may take some minutes. After successfull flashing &ldquo;SUCC&rdquo; is written on the display and the box reboots.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Analyzing Kernel Oops]]></title>
    <link href="http://sturmschneid.github.io/blog/2013/10/08/analyzing-kernel-oops/"/>
    <updated>2013-10-08T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2013/10/08/analyzing-kernel-oops</id>
    <content type="html"><![CDATA[<p>There was a little hickup in the kernel while shutting down or rebooting the system. The result of the hickup was a Kernel Oops. Because it had no big influence on the behaviour of the system I did not spend a lot of time on investigation. Yesterday I did some tests with the yocto workflow for kernel development and tried to fix the hickup.</p>

<h2>The hickup</h2>

<p>The Kernel Oops looked like this one</p>

<pre><code>Unmounting local filesystems...
[ 2135.692000] umount: sending ioctl 4c01 to a partition!
[ 2135.696000] umount: sending ioctl 4c01 to a partition!
Rebooting... [ 2137.744000] ------------[ cut here ]------------
[ 2137.744000] Badness at 80a859a0 [verbose debug info unavailable]
[ 2137.744000]
[ 2137.744000] Pid : 855, Comm:                 reboot
[ 2137.744000] CPU : 0                  Not tainted  (2.6.32.59_stm24_0211 #2)
[ 2137.744000]
[ 2137.744000] PC  : 80a859a0 SP  : 8928be48 SR  : 400080f1 TEA : c113ae28
[ 2137.744000] R0  : 00000000 R1  : 00000000 R2  : 80c22e7c R3  : 00002000
[ 2137.744000] R4  : 80c22ba4 R5  : 80a85610 R6  : 00000000 R7  : 00003fff
[ 2137.744000] R8  : 80c229cc R9  : 80a855fe R10 : 89ec440c R11 : 00000000
[ 2137.744000] R12 : fffff000 R13 : 80a859e0 R14 : 00000000
[ 2137.744000] MACH: 000000de MACL: 00000014 GBR : 296c1470 PR  : 80a859cc
[ 2137.744000]
[ 2137.744000] Call trace:
[ 2137.744000]  [&lt;80a85a04&gt;] 0x80a85a04
[ 2137.744000]  [&lt;80a5347a&gt;] 0x80a5347a
[ 2137.744000]  [&lt;809db332&gt;] 0x809db332
[ 2137.744000]  [&lt;8081f610&gt;] 0x8081f610
[ 2137.744000]  [&lt;8081f636&gt;] 0x8081f636
[ 2137.744000]  [&lt;8081f780&gt;] 0x8081f780
</code></pre>

<p>For me under yocto the best way to get in touch with the source is to start a devshell.</p>

<pre><code>bitbake -cdevshell virtual/kernel
</code></pre>

<p>While the occurence of the Oops the PC (program counter) was at address 0x80a859a0. So my first approach was loading the vmlinux in gdb. This was not that succefull because the kernel had no debug symbols included. The next source of information is the Sytem.map file:</p>

<pre><code>cat cat System.map | grep 80a859
80a85904 T _clk_disable
</code></pre>

<p>This looks like the cause of the problem is located in this function. To get a closer look I decided to compile the kernel with debug symbols. So I added the following config options:</p>

<pre><code>CONFIG_DEBUG_KERNEL=y
CONFIG_DETECT_SOFTLOCKUP=y
CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
CONFIG_DETECT_HUNG_TASK=y
CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
CONFIG_SCHED_DEBUG=y
CONFIG_DEBUG_PREEMPT=y
CONFIG_DEBUG_BUGVERBOSE=y
CONFIG_DEBUG_INFO=y
</code></pre>

<p>And recompiled the kernel</p>

<pre><code>bitbake -ccompile -f virtual/kernel
bitbake -cdeploy -f virtual/kernel
</code></pre>

<p>And finally copied the kernel onto the USB pendrive. Because I do the most of my testing while booting from USB.</p>

<pre><code>cp  tmp/deploy/images/uImage-spark.bin  /media/spark/uImage
</code></pre>

<p>After unmounting the pendrive I tested on the box with the follwing results:</p>

<pre><code>Unmounting local filesystems...
[   38.764000] umount: sending ioctl 4c01 to a partition!
[   38.768000] umount: sending ioctl 4c01 to a partition!
Rebooting... [   40.816000] ------------[ cut here ]------------
[   40.816000] Badness at drivers/stm/clk.c:190
[   40.816000]
[   40.816000] Pid : 779, Comm:                 reboot
[   40.816000] CPU : 0                  Not tainted  (2.6.32.59_stm24_0211 #2)
[   40.816000]
[   40.816000] PC  : 80a8b7e4 SP  : 88e59e44 SR  : 400080f1 TEA : c16772ac
[   40.816000] R0  : 00000000 R1  : 00000000 R2  : 80c2fe58 R3  : 00002000
[   40.816000] R4  : 80c2fb80 R5  : 80a8b438 R6  : 00000000 R7  : 00003fff
[   40.816000] R8  : 80c2f9a8 R9  : 80a8b426 R10 : 89e2048c R11 : 00000000
[   40.816000] R12 : fffff000 R13 : 80a8b824 R14 : 00000000
[   40.816000] MACH: 000000de MACL: 00000014 GBR : 296c1470 PR  : 80a8b810
[   40.816000]
[   40.816000] Call trace:
[   40.816000]  [&lt;80a8b84a&gt;] 0x80a8b84a
[   40.816000]  [&lt;80a58f9e&gt;] 0x80a58f9e
[   40.816000]  [&lt;809e055a&gt;] 0x809e055a
[   40.816000]  [&lt;8082188c&gt;] 0x8082188c
</code></pre>

<p>The Oops now tells me where I do have to look at:</p>

<pre><code>[   40.816000] Badness at drivers/stm/clk.c:190
</code></pre>

<p>The next test is to try what gdb tells me the address varies, because this is the kernel with the fix applied. But the mechanism is the same.</p>

<pre><code># sh4-poky-linux-gdb vmlinux
GNU gdb (GDB) 7.5.1
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "--host=x86_64-linux --target=sh4-poky-linux".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from vmlinux...done.
(gdb) list *(0x80a8b460)
0x80a8b460 is in _clk_disable (drivers/stm/clk.c:187).
182     return ret;
183 }
184 EXPORT_SYMBOL(clk_enable);
185
186 void _clk_disable(struct clk *clk)
187 {
188     int ret;
189
190
191     if (clk_is_always_enabled(clk)) {
(gdb)
</code></pre>

<p>With this information gdb can help to narrow the source of the problem. In my case I just googled the keywords stm and _clk_disable and found the following patch:
<a href="http://code.google.com/p/tdt-amiko/source/browse/tdt/cvs/cdk/Patches/linux-sh4-fix-crash-usb-reboot_stm24_0211.diff?spec=svnbf027b5e899cd26fbc20ac0745385c69ab385923&amp;r=bf027b5e899cd26fbc20ac0745385c69ab385923">linux-sh4-fix-crash-usb-reboot_stm24_0211.diff</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JFFS2 vs. UBIFS]]></title>
    <link href="http://sturmschneid.github.io/blog/2013/10/04/jffs2-vs-ubifs/"/>
    <updated>2013-10-04T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2013/10/04/jffs2-vs-ubifs</id>
    <content type="html"><![CDATA[<p>After a successfull merge of the <a href="https://github.com/project-magpie/linux-sh4-2.6.32.y/tree/ubifs-merge">UBIFS patches</a>  I have made some benchmarks. In both cases I have flashed the same image. It was a fresh build of core-image-minimal from the <a href="https://github.com/project-magpie/meta-stlinux/tree/dylan">dylan branch</a>. Maybe these benachmarks have to be repeated with a more representative scenario. More Information regarding <a href="http://en.wikipedia.org/wiki/UBIFS">UBIFS</a> can be found on <a href="http://elinux.org/UBIFS">eLinux</a>. If you are interested in more flash file system Benchmarks you can also have a look a <a href="http://elinux.org/Flash_Filesystem_Benchmarks">eLinux</a>.</p>

<h2>Mounting a JFFS2 Volume</h2>

<pre><code>root@spark:~# time mount /dev/mtdblock6  -tjffs2 /mnt/
real    0m 2.06s
user    0m 0.00s
sys     0m 2.06s
</code></pre>

<h2>Mounting a UBIFS volume</h2>

<pre><code>root@spark:~# time ubiattach -m6 &amp;&amp; time mount -tubifs ubi0:rootfs /mnt/
[  663.748000] UBI: attaching mtd6 to ubi0
[  663.752000] UBI: physical eraseblock size:   131072 bytes (128 KiB)
[  663.760000] UBI: logical eraseblock size:    129024 bytes
[  663.764000] UBI: smallest flash I/O unit:    2048
[  663.768000] UBI: sub-page size:              512
[  663.776000] UBI: VID header offset:          512 (aligned 512)
[  663.780000] UBI: data offset:                2048
[  663.940000] UBI: max. sequence number:       28
[  663.960000] UBI: attached mtd6 to ubi0
[  663.972000] UBI: MTD device name:            "E2 RootFs"
[  663.976000] UBI: MTD device size:            80 MiB
[  663.980000] UBI: number of good PEBs:        638
[  663.988000] UBI: number of bad PEBs:         2
[  663.992000] UBI: number of corrupted PEBs:   0
[  663.996000] UBI: max. allowed volumes:       128
[  664.000000] UBI: wear-leveling threshold:    4096
[  664.008000] UBI: number of internal volumes: 1
[  664.012000] UBI: number of user volumes:     1
[  664.016000] UBI: available PEBs:             0
[  664.020000] UBI: total number of reserved PEBs: 638
[  664.024000] UBI: number of PEBs reserved for bad PEB handling: 6
[  664.028000] UBI: max/mean erase counter: 1/0
[  664.032000] UBI: image sequence number:  1037100788
[  664.040000] UBI: background thread "ubi_bgt0d" started, PID 553
UBI device number 0, total 638 LEBs (82317312 bytes, 78.5 MiB), available 0 LEBs (0 bytes), LEB size 129024 bytes (126.0 KiB)
real    0m 0.31s
user    0m 0.00s
sys     0m 0.28s
[  664.092000] UBIFS: background thread "ubifs_bgt0_0" started, PID 556
[  664.160000] UBIFS: mounted UBI device 0, volume 0, name "rootfs"&lt;NULL&gt;
[  664.164000] UBIFS: LEB size: 129024 bytes (126 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
[  664.168000] UBIFS: FS size: 79607808 bytes (75 MiB, 617 LEBs), journal size 9033728 bytes (8 MiB, 71 LEBs)
[  664.172000] UBIFS: reserved for root: 0 bytes (0 KiB)
[  664.176000] UBIFS: media format: w4/r0 (latest is w4/r0), , small LPT model
real    0m 0.14s
user    0m 0.00s
sys     0m 0.11s
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[That Was a Close Shave!]]></title>
    <link href="http://sturmschneid.github.io/blog/2013/10/02/that-was-a-close-shave/"/>
    <updated>2013-10-02T00:00:00+02:00</updated>
    <id>http://sturmschneid.github.io/blog/2013/10/02/that-was-a-close-shave</id>
    <content type="html"><![CDATA[<p>While fiddling arround with the ubifs port I recently did. I misstyped the MTD Partion and completly erased mtd0. This sounds not that tragically, but on mtd0 u-boot is located. Without a bootloader there is only a small chance that the box will boot again. To reboot the box in such a situation is a absolut no go. Now you have to start brain work &hellip;</p>

<p>For the ubifs tests I have choosen the fresh dylan port of my <a href="https://github.com/project-magpie/meta-stlinux/tree/dylan">meta-stlinux</a> layer. This was a first draft and so I just build the ,,core-image-minimal&#8217;&lsquo;. I included the mtd-utils but I&rsquo;ve forgotten to include a ssh server aswell. This was not a big issue due to the fact that I used the serial line for connection. For testing I booted the box from USB. The USB was connect through a USB extension cable. Which cut me off from installing a fresh u-boot by inserting a USB Stick.</p>

<h2>What are the options?</h2>

<ul>
<li>Transfer the u-boot by zmodem</li>
<li>Transfer the u-boot by ethernet.</li>
</ul>


<p>The name minimal definitly means minimal. There was no serial command I did know to transer data. On the ethernet no SSH no telnet and of course no FTP. Okay lets start thinking&hellip;</p>

<p>BANG!!! my good old friend ,,netcat&#8217;&lsquo; one little test and yes there is a ,,nc&rsquo;&lsquo; command. The rest was easy going.</p>

<h2>How I solved the issue</h2>

<p>On the host PC start the server</p>

<pre><code>cat ~/uboot-alien.bin | nc -v -l 3333
</code></pre>

<p>Yes I do know alien is not the correct name for a golden media GM990 Box. But this was the only image I have found.</p>

<p>On the box I used this commands</p>

<pre><code># nc 192.168.24.157 3333 &gt; u-boot.bin
# du u-boot.bin
520     u-boot.bin
# flash_eraseall -j /dev/mtd0
flash_eraseall has been replaced by `flash_erase &lt;mtddev&gt; 0 0`; please use it
Erasing 64 Kibyte @ 0 --  0 % complete flash_erase:  Cleanmarker written at 0
Erasing 64 Kibyte @ 10000 -- 12 % complete flash_erase:  Cleanmarker written at 10000
Erasing 64 Kibyte @ 20000 -- 25 % complete flash_erase:  Cleanmarker written at 20000
Erasing 64 Kibyte @ 30000 -- 37 % complete flash_erase:  Cleanmarker written at 30000
Erasing 64 Kibyte @ 40000 -- 50 % complete flash_erase:  Cleanmarker written at 40000
Erasing 64 Kibyte @ 50000 -- 62 % complete flash_erase:  Cleanmarker written at 50000
Erasing 64 Kibyte @ 60000 -- 75 % complete flash_erase:  Cleanmarker written at 60000
Erasing 64 Kibyte @ 70000 -- 87 % complete flash_erase:  Cleanmarker written at 70000
Erasing 64 Kibyte @ 70000 -- 100 % complete
# flashcp u-boot.bin /dev/mtd0
# reboot
</code></pre>

<p>Now it was time to to keep one&rsquo;s fingers crossed. One deep breath later the box bootet like every time before.</p>

<pre><code>Board: STx7111-Mboard (MB618)  [32-bit mode]
info: Disregarding any EPLD


U-Boot 1.3.1 (Oct 19 2010 - 18:08:50) - stm23_0043 - YW 1.0.017 Rel

DRAM:  128 MiB
NOR:     8 MiB
NAND:  512 MiB
*** Warning - bad CRC, using default environment

In:    serial
Out:   serial
Err:   serial
IdentID : 09 00 07 00 00 46 d1
0  ESC to stop autoboot:  3
</code></pre>

<p>Except of the little message ,,*** Warning - bad CRC, using default environment&#8217;&lsquo; this was caused because by writing 512kb I have destroyed u-boot environment. I am not sure If this is the right u-boot. I would be happy If someone with a Golden Media Spark reloaded Box can send me a copy of the u-boot.</p>
]]></content>
  </entry>
  
</feed>
